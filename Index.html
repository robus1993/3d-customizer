<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Product Customizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Add any inline styles here if needed, as per the brief */
        body { background-color: #f0f0f0; }
        /* Tailwind can handle most styling */
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">

    <div id="loading" class="fixed inset-0 flex items-center justify-center bg-white z-50">
        <div class="text-xl font-bold">Loading... 0%</div>
    </div>

    <div id="three-container" class="w-full h-[80vh]"></div>

    <div class="bg-white p-6 rounded shadow-md mt-4">
        <h2 class="text-2xl font-bold mb-4">Customize Product</h2>
        <div class="flex flex-col space-y-4">
            <div>
                <label class="block mb-2">Product Color</label>
                <input id="product-color" type="color" class="w-full h-10">
            </div>
            <div>
                <label class="block mb-2">Upload Logo (.png)</label>
                <input id="logo-upload" type="file" accept=".png" class="w-full">
            </div>
        </div>
        <button id="apply-customization" class="bg-green-500 text-white px-4 py-2 mt-4 w-full">Apply Customization</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const container = document.getElementById('three-container');
        const loadingDiv = document.getElementById('loading');
        const colorPicker = document.getElementById('product-color');
        const logoUpload = document.getElementById('logo-upload');
        const applyBtn = document.getElementById('apply-customization');

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Baked camera settings
        camera.position.set(-0.14174618135894057, 2.1952267593971606, 10.254996729868925);
        camera.rotation.set(-0.06287602690434883, -0.011933009173710245, -0.0007512725447900868, 'XYZ');
        const focalLength = 50;
        const sensorHeight = 24; // mm, vertical
        camera.fov = 2 * Math.atan(sensorHeight / (2 * focalLength)) * (180 / Math.PI);
        camera.updateProjectionMatrix();

        // Baked ambient light
        const ambient = new THREE.AmbientLight('#ffffff', 0);
        scene.add(ambient);

        // Baked lights
        const lightsData = [
            { type: 'DirectionalLight', color: '#0040ff', intensity: 7.25, position: [7.7, 3.8, -17.2] },
            { type: 'DirectionalLight', color: '#ffffff', intensity: 3.44, position: [-1.5, 5, 5] },
            { type: 'DirectionalLight', color: '#ffffff', intensity: 1.6, position: [0, 5, -5] }
        ];

        lightsData.forEach(data => {
            let light;
            if (data.type === 'DirectionalLight') {
                light = new THREE.DirectionalLight(data.color, data.intensity);
                light.position.set(...data.position);
                light.target = new THREE.Object3D(); // Target at origin
                scene.add(light.target);
            } // Add other types if needed in future
            scene.add(light);
        });

        // Model loading
        const glbUrl = './scene-optimized.glb'; // Assuming the GLB file is in the same directory as index.html on your Netlify site
        const loader = new GLTFLoader();
        loader.setMeshoptDecoder(MeshoptDecoder);
        let colorObjects = [];
        let decalObjects = [];
        loader.load(
            glbUrl,
            (gltf) => {
                scene.add(gltf.scene);

                // Identify objects
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        if (child.name.startsWith('Color')) colorObjects.push(child);
                        if (child.name.startsWith('Decal')) decalObjects.push(child);
                    }
                });

                // Center the model
                const box = new THREE.Box3().setFromObject(gltf.scene);
                const center = box.getCenter(new THREE.Vector3());
                controls.target.copy(center);
                camera.lookAt(center);

                // Hide loading
                loadingDiv.style.display = 'none';
            },
            (xhr) => {
                const percent = Math.round((xhr.loaded / xhr.total) * 100);
                loadingDiv.innerHTML = `<div class="text-xl font-bold">Loading... ${percent}%</div>`;
            },
            (error) => console.error('An error happened', error)
        );

        // Customization logic
        let selectedColor = new THREE.Color(colorPicker.value);
        let logoImageFile = null;

        colorPicker.addEventListener('input', (e) => {
            selectedColor.set(e.target.value);
        });

        logoUpload.addEventListener('change', (e) => {
            logoImageFile = e.target.files[0];
        });

        applyBtn.addEventListener('click', () => {
            // Apply color
            colorObjects.forEach((mesh) => {
                mesh.material.color.set(selectedColor);
            });

            // Apply logo
            if (logoImageFile) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const canvasSize = 1024; // High res for texture
                        const canvas = document.createElement('canvas');
                        canvas.width = canvasSize;
                        canvas.height = canvasSize;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvasSize, canvasSize);

                        // Scale and center with 80% fit (20% margin total, 10% each side)
                        const fitRatio = 0.8;
                        const scale = Math.min((canvasSize * fitRatio) / img.width, (canvasSize * fitRatio) / img.height);
                        const dw = img.width * scale;
                        const dh = img.height * scale;
                        const dx = (canvasSize - dw) / 2;
                        const dy = (canvasSize - dh) / 2;

                        ctx.drawImage(img, dx, dy, dw, dh);

                        const texture = new THREE.CanvasTexture(canvas);
                        texture.flipY = false;

                        decalObjects.forEach((mesh) => {
                            if (mesh.material.map) mesh.material.map.dispose();
                            mesh.material.map = texture;
                            mesh.material.needsUpdate = true;
                        });
                    };
                };
                reader.readAsDataURL(logoImageFile);
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>

</body>
</html>